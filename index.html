<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Galaxy for XHY</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; cursor: pointer; }
        #container { width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 40px; left: 40px; z-index: 10; pointer-events: none; }
        h1 { color: #fff; font-weight: 300; letter-spacing: 6px; margin: 0; text-shadow: 0 0 20px #0a4990; }
        .hint { color: #5289e2; opacity: 0.8; font-size: 13px; margin-top: 12px; text-transform: uppercase; letter-spacing: 2px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #5875a4; z-index: 100; font-size: 16px; text-align: center; letter-spacing: 3px; }
        .progress-bar { width: 180px; height: 1px; background: rgba(160,196,255,0.1); margin: 15px auto; position: relative; }
        #progress { width: 0%; height: 100%; background: #a0c4ff; transition: width 0.4s; box-shadow: 0 0 10px #a0c4ff; }
    </style>
</head>
<body>

<div id="loading">
    <div id="load-text">LOADING PARTICLES...</div>
    <div class="progress-bar"><div id="progress"></div></div>
</div>

<div id="ui">
    <h1 id="title">CHRISTMAS EVE</h1>
    <p class="hint">CLICK TO TRANSFORM: TREE ➔ WISH ➔ APPLE</p>
</div>

<div id="message-overlay" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 20; pointer-events: none; width: 100%;">
    <h1 class="main-title" style="font-size: 5em; color: #fff; text-shadow: 0 0 30px #22aaff, 0 0 10px #fff; font-family: 'Segoe UI', serif; margin: 0; opacity: 0; transition: opacity 2s;">Merry Christmas<br><span style="font-size: 0.5em; letter-spacing: 10px;">TO XHY</span></h1>
</div>

<div id="container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';

    const CONFIG = {
        particleCount: 15000, // Increased count for better text
        colors: {
            white: new THREE.Color(0xffffff),
            blue: new THREE.Color(0x22aaff),
            lightBlue: new THREE.Color(0x88ccff),
            gold: new THREE.Color(0xffd700),
            leafGreen: new THREE.Color(0x44ff44),
            appleRed: new THREE.Color(0xff3333) 
        }
    };

    let scene, camera, renderer, composer, clock;
    let iMesh; 
    let particles = [];
    let currentState = 0;
    let fontLoaded = false;
    let starField;

    const dummy = new THREE.Object3D();

    init();

    async function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.005); // Dark blue fog
        scene.background = new THREE.Color(0x000205); // Very dark blue bg
        clock = new THREE.Clock();
        
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 120);

        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        // Enhanced Bloom
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 1.5; // Reduced glow strength
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.1;

        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(bloomPass);

        createStarField();

        updateProgress(30, "GENERATING PARTICLES...");
        setupBaseParticles();

        updateProgress(100, "READY");
        setTimeout(() => document.getElementById('loading').style.display='none', 600);
        animate();

        window.addEventListener('resize', onResize);
        window.addEventListener('mousedown', toggleState);
        window.addEventListener('touchstart', toggleState, { passive: false }); // Mobile touch support
    }

    function updateProgress(val, text) {
        document.getElementById('progress').style.width = val + '%';
        document.getElementById('load-text').innerText = text;
    }

    function createStarField() {
        const geometry = new THREE.BufferGeometry();
        const count = 2000;
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        for(let i=0; i<count; i++) {
            positions[i*3] = (Math.random() - 0.5) * 400;
            positions[i*3+1] = (Math.random() - 0.5) * 400;
            positions[i*3+2] = (Math.random() - 0.5) * 200 - 50;
            
            const col = new THREE.Color(0xffffff);
            if(Math.random() > 0.8) col.setHex(0xa0c4ff); // Blueish stars
            colors[i*3] = col.r;
            colors[i*3+1] = col.g;
            colors[i*3+2] = col.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        starField = new THREE.Points(geometry, material);
        scene.add(starField);
    }

    function setupBaseParticles() {
        const geo = new THREE.TetrahedronGeometry(0.4); 
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
        });
        
        iMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
        iMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(iMesh);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            let posTree, posApple, c;
            const isStar = i < 350; // Star particles
            const isRibbon = i >= 350 && i < 1750; // Ribbon particles
            const isLeaf = i > CONFIG.particleCount - 200;

            // --- STATE 0: TREE ---
            if (isStar) {
                // Improved 5-Pointed Star Shape
                const segment = Math.floor(Math.random() * 10);
                const angleStep = Math.PI / 5; // 36 degrees
                const baseAngle = segment * angleStep;
                
                const R_out = 4.5;
                const R_in = 1.8;
                
                // Vertices of the current triangle segment (0,0), P1, P2
                const r1 = (segment % 2 === 0) ? R_out : R_in;
                const r2 = (segment % 2 === 0) ? R_in : R_out;
                
                const a1 = baseAngle;
                const a2 = baseAngle + angleStep;
                
                // Random point in triangle
                let u = Math.random();
                let v = Math.random();
                if (u + v > 1) { u = 1 - u; v = 1 - v; }
                
                const p1x = r1 * Math.cos(a1);
                const p1y = r1 * Math.sin(a1);
                const p2x = r2 * Math.cos(a2);
                const p2y = r2 * Math.sin(a2);
                
                // Base position in XY plane
                const x = u * p1x + v * p2x;
                const y = u * p1y + v * p2y;
                
                // Thickness tapers from center
                const dist = Math.sqrt(x*x + y*y);
                const thickness = 2.0 * (1 - dist / R_out);
                const z = (Math.random() - 0.5) * thickness;
                
                posTree = new THREE.Vector3(x, y + 39, z);
                c = CONFIG.colors.gold;
            } else if (isRibbon) {
                // Ribbon spiral
                // t goes from 0 to 1
                const t = (i - 350) / 1400; 
                const spiralTurns = 6;
                const angle = t * Math.PI * 2 * spiralTurns;
                const y = 35 - t * 70; // Top to bottom
                const heightFactor = (y + 35) / 70;
                const baseRadius = 30 * (1 - heightFactor) + 1;
                const ribbonRadius = baseRadius + 2; // Slightly outside
                
                posTree = new THREE.Vector3(
                    Math.cos(angle) * ribbonRadius,
                    y,
                    Math.sin(angle) * ribbonRadius
                );
                
                // Ribbon color: Gold or Bright White
                c = new THREE.Color(0xffddaa); 
            } else {
                // Tree Body
                const angle = Math.random() * Math.PI * 2;
                const y = Math.random() * 70 - 35;
                const heightFactor = (y + 35) / 70; 
                const radius = 30 * (1 - heightFactor) + 1;
                const spiralAngle = angle + y * 0.1;
                
                posTree = new THREE.Vector3(
                    Math.cos(spiralAngle) * radius,
                    y,
                    Math.sin(spiralAngle) * radius
                );
                posTree.x += (Math.random() - 0.5) * 2;
                posTree.z += (Math.random() - 0.5) * 2;
                
                // Tree Color
                c = new THREE.Color();
                if (Math.random() > 0.3) c.copy(CONFIG.colors.blue);
                else if (Math.random() > 0.5) c.copy(CONFIG.colors.lightBlue);
                else c.copy(CONFIG.colors.white);
                if (Math.random() > 0.95) c.copy(CONFIG.colors.gold);
            }

            // --- STATE 1: GALAXY (Background for Text) ---
            // Random scatter
            const posGalaxy = new THREE.Vector3(
                (Math.random() - 0.5) * 300,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 100 - 50
            );

            // --- STATE 2: APPLE ---
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            const r = 30;
            
            let ay = r * Math.cos(v);
            let ax = r * Math.sin(v) * Math.cos(u);
            let az = r * Math.sin(v) * Math.sin(u);
            
            let posAppleVec = new THREE.Vector3(ax, ay * 0.85, az);
            
            // Dimples
            if (posAppleVec.y > 15) {
                const d = (posAppleVec.y - 15) / 10;
                posAppleVec.x *= (1 - d * 0.5);
                posAppleVec.z *= (1 - d * 0.5);
                posAppleVec.y -= d * 5;
            }
            if (posAppleVec.y < -15) {
                const d = (-15 - posAppleVec.y) / 10;
                posAppleVec.x *= (1 - d * 0.5);
                posAppleVec.z *= (1 - d * 0.5);
                posAppleVec.y += d * 3;
            }
            
            if (isLeaf) {
                const l_u = Math.random() * Math.PI;
                const l_v = Math.random() * Math.PI;
                posAppleVec.set(
                    5 + Math.cos(l_u) * 5,
                    22 + Math.sin(l_v) * 2,
                    Math.sin(l_u) * 3
                );
            }

            particles.push({
                curPos: posTree.clone(),
                targets: [posTree, posGalaxy, posAppleVec], 
                phase: Math.random() * Math.PI * 2,
                speed: 0.05 + Math.random() * 0.05,
                isLeaf: isLeaf,
                isStar: isStar,
                isRibbon: isRibbon
            });
            
            iMesh.setColorAt(i, c);
        }
    }

    function calculateFontPositions(f) {
        const message = "Merry\nChristmas";
        const shapes = f.generateShapes(message, 12); // Slightly larger font
        const points = [];
        
        // Center the text
        const geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
        const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
        const yMid = - 0.5 * ( geometry.boundingBox.max.y - geometry.boundingBox.min.y );

        shapes.forEach(s => {
            const shapePts = s.getPoints(220); // Much higher density for legibility
            shapePts.forEach(p => {
                points.push(new THREE.Vector3(p.x + xMid, p.y + yMid, 0));
            });
        });

        // Assign to particles
        particles.forEach((p, i) => {
            if(i < points.length) {
                p.targets[1].copy(points[i]);
                // Reduce depth jitter for clearer text
                p.targets[1].z += (Math.random() - 0.5) * 2;
            } else {
                // Extra particles form a ring or background
                const angle = Math.random() * Math.PI * 2;
                const r = 60 + Math.random() * 20;
                p.targets[1].set(
                    Math.cos(angle) * r,
                    (Math.random() - 0.5) * 80,
                    Math.sin(angle) * r
                );
            }
        });
    }

    function toggleState() {
        // if(!fontLoaded) return; // Removed font check
        currentState = (currentState + 1) % 3;
        
        const title = document.getElementById('title');
        const names = ["CHRISTMAS EVE", "BEST WISHES", "PEACE & JOY"];
        title.innerText = names[currentState];

        // Toggle HTML Overlay
        const overlay = document.getElementById('message-overlay');
        const mainTitle = overlay.querySelector('.main-title');
        
        if (currentState === 1) {
            overlay.style.display = 'block';
            // Trigger reflow
            void overlay.offsetWidth;
            mainTitle.style.opacity = '1';
        } else {
            mainTitle.style.opacity = '0';
            setTimeout(() => {
                if(currentState !== 1) overlay.style.display = 'none';
            }, 1000);
        }

        // Update colors based on state
        particles.forEach((p, i) => {
            const c = new THREE.Color();
            if (currentState === 2 && p.isLeaf) {
                c.copy(CONFIG.colors.leafGreen);
            } else if (currentState === 2) {
                // Apple body - Red
                if (Math.random() > 0.3) c.copy(CONFIG.colors.appleRed);
                else c.copy(new THREE.Color(0xff6666)); // Lighter red variation
            } else {
                // Tree & Text
                if (p.isStar && currentState === 0) {
                    c.copy(CONFIG.colors.gold);
                } else if (p.isRibbon && currentState === 0) {
                    c.setHex(0xffddaa); // Ribbon color
                } else {
                    if (Math.random() > 0.3) c.copy(CONFIG.colors.blue);
                    else if (Math.random() > 0.5) c.copy(CONFIG.colors.lightBlue);
                    else c.copy(CONFIG.colors.white);
                    if (Math.random() > 0.95) c.copy(CONFIG.colors.gold);
                }
            }
            iMesh.setColorAt(i, c);
        });
        iMesh.instanceColor.needsUpdate = true;
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        particles.forEach((p, i) => {
            const target = p.targets[currentState];
            
            // Move
            p.curPos.lerp(target, p.speed);
            
            dummy.position.copy(p.curPos);
            
            // Ribbon Animation (only in Tree state)
            if (p.isRibbon && currentState === 0) {
                // Rotate ribbon particles around Y axis to simulate flow
                // We can just add to the angle based on time
                const flowSpeed = 0.5;
                const angleOffset = time * flowSpeed;
                const x = dummy.position.x;
                const z = dummy.position.z;
                
                // Rotate (x,z)
                dummy.position.x = x * Math.cos(angleOffset) - z * Math.sin(angleOffset);
                dummy.position.z = x * Math.sin(angleOffset) + z * Math.cos(angleOffset);
            }

            // Twinkle / Float
            const noise = Math.sin(time * 2 + p.phase);
            dummy.scale.setScalar(1 + noise * 0.3);
            
            // Rotate particles
            dummy.rotation.x = time + p.phase;
            dummy.rotation.y = time + p.phase;

            dummy.updateMatrix();
            iMesh.setMatrixAt(i, dummy.matrix);
        });
        
        iMesh.instanceMatrix.needsUpdate = true;
        
        // Rotate scene slowly
        if (currentState === 0) {
            scene.rotation.y -= 0.004; // Continuous rotation
        } else if (currentState === 2) {
            scene.rotation.y += 0.005;
        } else {
            scene.rotation.y *= 0.95; // Stop rotation for text
        }
        
        // Starfield twinkle
        if(starField) {
            starField.rotation.y -= 0.0005;
        }

        composer.render();
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }
</script>

</body>
</html>